\setcounter{chapter}{0}
<#define currentChapter |1>

# Основы

Есть мнение, что Haskell очень большой язык. Это и правда так.
В Haskell много разных конструкций, синтаксического сахара, которые
делают код более наглядным. Также в Haskell много библиотек на
разные случаи жизни. Однако, обману ли я 
ваши ожидания, сказав, что всё это имеет достаточно компактную 
основу? Это и правда так, вам осталось лишь убедиться в 
наглядности и простоте Haskell. В этой главе мы пробежимся по 
нему, охватив одним взглядом целиком весь язык. Несколько 
наглядных конструкций, немного моих пояснений, и вы поймёте, что 
к чему. Если что-то сразу не станет ясно, или где-то я опущу 
какие-то пояснения, будьте уверены -- в следующих главах мы 
обязательно обратимся к этим моментам и обсудим их подробнее. 

## Общая картина


Программы на Haskell бывают двух видов: это 
*приложения* (executable) и *библиотеки* (library).
Приложения представляют собой исполняемые файлы, которые решают
некоторую задачу, к примеру -- это может быть компилятор языка, 
сортировщик данных в директориях, календарь, или цитатник на каждый день,
любая полезная утилита.
Библиотеки тоже решают задачи, но решают их внутри самого языка.
Они содержат отдельные значения, функции, которые можно подключать
к другой программе Haskell, и которыми можно пользоваться.


Программа состоит из *модулей* (module). И здесь работает 
правило: один модуль -- один файл. Имя модуля совпадает с именем файла.
Имя модуля начинается с большой буквы, тогда как файлы имеют 
расширение `.hs`.
Например `FirstModule.hs`. Посмотрим на типичный модуль в Haskell:

~~~
--------------------------------------
-- шапка

module Имя(определение1, определение2,..., определениеN) where

import Модуль1(...)
import Модуль2(...)
...

---------------------------------------
-- определения

определение1
определение2
...
~~~

Каждый модуль содержит набор 
определений. Относительно модуля определения делятся на 
*экспортируемые* и *внутренние*. Экспортируемые определения 
могут быть использованы за пределами модуля, а внутренние -- только
внутри модуля, и обычно они служат для выражения экспортируемых определений.

Модуль состоит из двух частей -- шапки и определений.

*Шапка*

:   В шапке после слова `module` объявляется имя модуля, 
    за которым в скобках следует список экспортируемых 
    определений; после скобок стоит слово `where`.
    Затем идут импортируемые модули. С помощью импорта
    модулей вы имеете возможность в данном модуле пользоваться определениями
    из другого модуля.

    Как после имени модуля, так и в директиве 
    `import` скобки с определениями можно не писать,так 
    как в этом     случае считается, что экспортируются/импортируются все 
    определения.

*Определения*

:   Эта часть содержит все определения модуля, при этом порядок 
    следования определений не имеет значения. То есть, не
    обязательно пользоваться в данной функции лишь теми значениями,
    что были определены выше.


Модули взаимодействуют друг с другом с помощью экспортируемых определений.
Один модуль может сказать, что он хочет воспользоваться экспортируемыми
определениями другого модуля, для этого он пишет 
`import Модуль(определения)`. Модуль -- это айсберг, 
на вершине которого -- те функции, ради которых он 
создавался (экспортируемые), а под водой -- все служебные 
детали реализации (внутренние).

Итак, программа состоит из модулей, модули состоят из определений.
Но что такое определения?

В Haskell определения могут описывать четыре вида сущностей:

* Типы.

* Значения.

* Классы типов.

* Экземпляры классов типов.


Теперь давайте рассмотрим их подробнее.


## Типы

Типы представляют собой каркас программы. Они кратко
описывают все возможные значения. Это очень удобно.
Опытный программист на Haskell может понять смысл
функции по её названию и типу. Это не очень сложно.
Например, мы видим:

~~~
not :: Bool -> Bool
~~~

Выражение `v :: T` означает, что значение
`v` имеет тип `T`. Стрелка `a -> b`
означает функцию, то есть из `a` мы можем получить `b`.
Итак, перед нами функция из `Bool` в `Bool`,
под названием `not`. Мы можем предположить, что
это логическая операция "не". 
Или, перед нами такое определение типа:

~~~
reverse :: [a] -> [a]
~~~

Мы видим функцию с именем `reverse`, которая принимает
список `[a]` и возвращает список `[a]`, и мы
можем догадаться, что эта функция переворачивает список, то есть
мы получаем список, у которого элементы идут в обратном порядке.
Маленькая буква `a` в `[a]` является параметром типа,
на место параметра может быть поставлен любой тип.
Она говорит о том, что список содержит элементы типа `a`.
Например, такая функция соглашается переворачивать только
списки логических значений:

~~~
reverseBool :: [Bool] -> [Bool]
~~~

Программа представляет собой описание
некоторого явления или процесса. Типы определяют 
основные слова или термины и способы их комбинирования.
А значения представляют собой комбинации базовых 
слов. Но значения комбинируются не произвольным
образом, а на основе определённых правил, которые 
задаются типами. 

Например, такое выражение определяет тип, в котором
два базовых термина `True` или `False`

~~~
data Bool = True | False
~~~

Слово `data` ключевое, с него 
начинается любое определение нового
типа. Символ `|` означает или. Наш новый тип `Bool`
является либо словом `True`, либо словом `False`.
В этом типе есть только понятия, но нет способов комбинирования,
посмотрим на тип, в котором есть и то, и другое:

~~~
data [a] = [] | a : [a]
~~~

Это определение списка. Как мы уже поняли, `a` -- это параметр.
Список `[a]` может быть либо пустым списком `[]`, либо
комбинацией `a : [a]`. В этой комбинации знак `:` объединяет
элемент типа `a` и ещё один список `[a]`. Это рекурсивное
определение, они встречаются в Haskell очень часто.
Если это пока кажется непонятным, не пугайтесь, в следующих
главах будет представлено много примеров с пояснениями.

Приведём ещё несколько примеров определений; ниже
типы определяют базовые понятия для мира календаря: 
то что стоит за `--` является
комментарием и игнорируется при выполнении программы: 

~~~
-- Дата
data Date = Date Year Month Day

-- Год
data Year  = Year Int       -- Int это целые числа

-- Месяц
data Month  = January    | February   | March    | April          
            | May        | June       | July     | August   
            | September  | October    | November | December 

data Day = Day Int

-- Неделя
data Week  = Monday     | Tuesday   | Wednesday 
           | Thursday   | Friday    | Saturday     
           | Sunday     

-- Время
data Time = Time Hour Minute Second

data Hour   = Hour   Int    -- Час
data Minute = Minute Int    -- Минута
data Second = Second Int    -- Секунда
~~~

Одной из основных целей разработчиков Haskell была 
ясность. Они стремились создать язык, предложения которого
будут простыми и понятными, близкий к языку спецификаций.

С символом `|` мы уже познакомились, он указывает на альтернативы,
объединение пишется через пробел. Так, фраза

~~~
data Time = Time Hour Minute Second
~~~

означает, что тип `Time` -- это значение с меткой `Time`,
которое состоит из значений типов "час", "время" и 
"секунда", и больше ничего. Метку принято называть 
*конструктором*.

Фраза

~~~
data Year = Year Int
~~~

означает, что тип `Year` -- это значение с 
конструктором `Year`,
которое состоит из одного значения типа `Int`.
Конструктор обычно идёт первым, а за ним через пробел следуют 
другие типы. Конструктор может быть и самостоятельным значением,
как в случае `True` или `January`.

Типы делят выполнение программы на две стадии: *компиляцию*
(compile-time) и *вычисление* (run-time). На этапе 
компиляции происходит проверка типов. Программа, которая
не прошла проверку типов, считается бессмысленной и не
вычисляется. Приложение, которое выполняет компиляцию,
называют *компилятором* (compiler), а то приложение, которое 
проводит вычисление, называют *вычислителем* (run-time system).

Типами мы определяем основные понятия в том явлении,
которое мы хотим описать, а также осмысленные способы
их комбинирования. Мы говорим, как из простейших терминов
получаются составные. 
Если мы попытаемся построить 
бессмысленное предложение, компилятор языка автоматически 
найдёт такое предложение и сообщит нам об этом. 
Этот процесс заключается в проверке
типов, к примеру если у нас есть функция сложения чисел, и 
мы попытаемся передать в неё строку или список, компилятор
заметит это и скажет нам об этом *перед* тем как программа
начнёт выполнятся. И важно то, что это произойдёт очень быстро.
Если мы случайно ошиблись в выражении, которое будет вычислено
через час, нам не нужно ждать пока вычислитель дойдёт до ошибки, мы
узнаем об этом, не успев моргнуть, после запуска программы.

Итак, если мы попробуем составить время из месяцев и логических
значений:

~~~
Time January True 23
~~~

компилятор предупредит нас об ошибке. Наверное, вы 
думаете, что приведенный пример надуман, ведь кому 
захочется составлять время из логических значений? Но когда 
вы пишете программу, часто процесс работы складывается так:
вы думаете над одним, пишете другое, а также планируете вернуться
к третьему. И знание того, что есть надежный компилятор, который
не пропустит глупых ошибок, освобождает руки, вы можете не 
заботиться о таких пустяках, как правильное построение предложения. 

Отметим, что такой подход с разделением вычисления на
две стадии и проверкой типов называется 
*статической типизацией*.
Есть и другие языки, в них типы лишь подразумеваются 
и программа сразу начинает вычисляться, если есть какие-то
несоответствия, об ошибке программисту сообщит вычислитель,
причём только тогда, когда вычисление дойдёт до ошибки.
Такой подход называют *динамической типизацией*.

Типы требуют серьёзных размышлений на начальном этапе, этапе определения
базовых терминов и способов их комбинирования. Не упускаем ли
мы что-то важное из виду, или, может быть, типы имеют слишком 
общий характер и допускают ненужные нам предложения? Приходится 
задумываться. Но если типы подобраны удачно, они сами
начинают подсказывать, как строить программу.

## Значения

Итак, мы определили типами базовые понятия и способы комбинирования.
Обычно это небольшой набор слов. Например в логических выражениях
всего лишь два слова. Можем ли мы на что либо рассчитывать с 
таким словарным запасом? Оказывается, что да. Здесь на помощь 
приходят синонимы. Сейчас у нас в активе лишь два слова:

~~~
data Bool = True | False
~~~


И мы можем определить два синонима:

~~~
true :: Bool
true = True

false :: Bool
false = False
~~~

В Haskell синонимы пишутся с маленькой буквы. Синоним 
определяется через знак `=`. Обратите внимание на то, что
это не процесс вычисления значения. Мы всего лишь объявляем 
новое имя для комбинации слов. 

Теперь мы имеем целых четыре слова! Тем не менее, ушли мы не 
далеко, и два новых
слова, в сущности, не делают язык выразительнее.
Такие синонимы называют *константами*. Это значит, 
что одним словом мы будем обозначать некоторую комбинацию других слов.
В данном случае комбинации очень простые.

Но наши синонимы могут определять одни слова через другие. 
Синонимы могут принимать параметры. Параметры пишутся через
пробел между новым именем и знаком равно:

~~~
not :: Bool -> Bool
not True  = False
not False = True
~~~

Мы определили новое имя `not` с типом `Bool -> Bool`. 
Оно определяется двумя *уравнениями* (clause). Слева
от знака равно левая часть уравнения, а справа -- правая.
В первом уравнении мы говорим, что сочетание `(not True)`
означает `False`, а сочетание `(not False)` означает
`True`. Опять же, мы ничего не вычисляем, мы даём новые имена
нашим константам `True` и `False`. Только в этом случае
имена составные. 

Если вычислителю нужно узнать, что кроется за составным именем
`not False`
он *последовательно* проанализирует уравнения сверху вниз, до тех
пор, пока левая часть уравнения не совпадёт со значением *not False*.
Сначала мы сверим с первым:

~~~
not True   == not False     -- нет, пошли дальше
not False  == not False     -- эврика, вернём правую часть
=> True
~~~

Определим ещё два составных имени 

~~~
and :: Bool -> Bool -> Bool
and False  _  = False
and True   x  = x

or  :: Bool -> Bool -> Bool
or True   _ = True
or False  x = x
~~~

Эти синонимы определяют логические операции "и"
и "или". Здесь несколько новых конструкций, 
но вы не пугайтесь, они не так трудны для понимания. Начнём с `_`:

~~~
and False  _  = False
~~~

Здесь символ `_` означает, что в этом уравнении, 
если первый параметр равен `False`, то второй нам уже 
не важен, мы знаем ответ. Так, если в логическом "и"
один из аргументов равен `False`, то всё выражение
равно `False`. Так же и в случае с `or`.

Теперь другая новая конструкция:

~~~
and True   x  = x
~~~

В этом случае параметр `x` служит для того, чтобы 
перетащить значение из аргумента в результат. 
Конкретное значение нам также не важно, но в этом
случае мы полагаем, что слева и справа от `=`,
`x` имеет одно и то же значение.

Итак у нас уже целых семь имён: `True`, `False`,
`true`, `false`, `not`, `and`, `or`. Или не семь? 
На самом деле, их уже бесконечное множество. Поскольку
три из них составные, мы можем создавать самые разнообразные 
комбинации:

~~~
not (and true False)
or (and true true) (or False False)
not (not true)
not (or (or True True) (or False (not True)))
...
~~~

Обратите внимание на использование скобок, они группируют 
значения. Так, если бы мы написали `not not true` вместо
`not (not true)`, мы бы получили ошибку компиляции, потому
что `not` ожидает один параметр, а в выражении `not not true`
их два. Параметры дописываются к имени через пробел.

Посмотрим, как происходят вычисления. В сущности, 
процесса вычислений нет, есть процесс замены синонимов
на основные понятия согласно уравнениям. Базовые понятия мы 
определили в типах. 
Так давайте "вычислим" выражение `not (and true False)`:

~~~
-- выражение            --  уравнение

not (and true False)    --  true        = True
not (and True False)    --  and True  x = x     => and True False = False
not False               --  not False   = True
True
~~~

Слева в столбик написаны шаги "вычисления", а справа 
уравнения, по которым синонимы заменяются на комбинации
слов. Процесс замены синонима (левой части уравнения) на
комбинацию слов (правую часть уравнения) называется 
*редукцией* (reduction). 

Сначала мы заменили синоним `true` на правую часть
его уравнения, тo есть на конструктор `True`. Затем мы заменили
выражение `(and True False)` на правую часть из уравнения
для синонима `and`. Обратите внимание на то, что переменная
`x` была заменена на значение `False`.
Последним шагом была замена синонима
`not`. В конце концов мы пришли к базовому понятию, а именно -- к 
одному из двух конструкторов. В данном случае `True`.

Интересно, что новые синонимы могут быть использованы 
в правых частях уравнений. Так мы можем определить операцию
"исключающее или":

~~~
xor :: Bool -> Bool -> Bool
xor a b = or (and (not a) b) (and a (not b))
~~~

Этим выражением мы говорим, что `xor a b` это
или отрицание `a` и `b`, или `a` и отрицание `b`.
Это и есть определение "исключающего или".

Может показаться, что с типом `Bool` мы зациклены
на двух конструкторах, и единственное, что нам остаётся -- 
это давать всё новые и новые имена словам `True`
и `False`. Но на самом деле это не так. 
С помощью типов-параметров мы можем выйти за эти рамки.
Определим функцию ветвления `ifThenElse`:

~~~
ifThenElse :: Bool -> a -> a -> a
ifThenElse True   t  _ = t
ifThenElse False  _  e = e
~~~

Эта функция первым аргументом принимает значение
типа `Bool`, а вторым и третьим -- альтернативы 
некоторого типа `a`. Если первый аргумент --
`True`, возвращается второй аргумент, а если -- `False`,
то третий. 

Интересно, что в Haskell ничего не происходит,
мир Haskell-значений стоит на месте. Мы просто даём 
имена разным комбинациям слов. Определяем новые термины.
Потом на этих терминах определяем  новые термины,
и так далее. Кажется, если ничего не меняется, то зачем 
язык? И что мы собираемся программировать без вычислений? 

Разгадка кроется в функциях `not`, `and` и `or`.
До того как мы их определили, у нас было четыре имени, но
после их определения имён стало бесконечное множество.
Три синонима пополнили наш язык бесконечным набором
комбинаций. В этом суть. Мы определяем базовые элементы
и способы составления новых, потом мы просим 
"вычислить" комбинацию из них. Мы не определяли
явно, 
чему равна комбинация `not (and true False)`, это сделал за 
нас вычислитель Haskell[^1].

[^1]:   Было бы точнее называть вычислитель редуктором,
        поскольку мы проводим редукции, или замену эквивалентных
        значений, но закрепилось это название. 
        К тому же, редуктор также обозначает прибор.

       
Вычислить стоит в кавычках, потому что на самом деле
вычислений нет, есть замена синонимов на комбинации простейших
элементов.


Ещё один пример, положим у нас есть тип:

~~~
data Status = Work | Rest
~~~

Он определяет, что делать в данный день: работать (`Work`)
или отдыхать (`Rest`). У разных рабочих разный график.
Например, есть функции:

~~~
jonny :: Week -> Status
jonny x = ...

colin :: Week -> Status
colin x = ...
~~~

Конкретное определение сейчас не важно, важно, что они определяют
зависимость статуса (`Status`) от дня недели (`Week`) для 
работников Джонни (`jonny`) и Колина (`colin`). 

Также у нас есть полезная функция:

~~~
calendar :: Date -> Week
calendar x = ...
~~~

Она определяет по дате день недели. И теперь, зная лишь
эти функции, мы можем спросить у вычислителя будет ли
у Джонни выходной 8 августа 3043 года:

~~~
jonny (calendar (Date (Year 3043) August (Day 8)))
=> jonny Saturday
=> Rest
~~~

Интересно, у нас опять всего лишь два значения, 
но, дав такое большое имя одному из значений,
мы смогли получить полезную нам информацию,
ничего не вычисляя.


## Классы типов

Если типы и значения -- привычные понятия, которые можно найти
в том или ином виде в любом языке программирования, то термин 
класс типов встречается не часто. У него нет аналогов и в 
обычном языке, поэтому я сначала постараюсь объяснить 
его смысл на примере. 

В типизированном языке у каждой 
функции есть тип, но бывают функции, которые могут быть 
определены на аргументах разных типов; по сути, они описывают
схожие понятия, но определены для значений разных типов.
Например, функция сравнения на равенство, говорящая о том, что два значения 
одного типа `a` равны, имеет тип `a -> a -> Bool`, 
или функция печати выражения имеет тип `a -> String`,
но что такое `a` в этих типах? Тип `a` является
любым типом, для которого сравнение на равенство или 
печать (преобразование в строку) имеют смысл. Это
понятие как раз и кодируется в классах типов. 
`Классы типов` (type class)
позволяют определять функции с одинаковым
именем для разных типов. 

У классов типов есть имена. Также как и имена классов, 
они начинаются с большой буквы. Например, класс сравнений 
на равенство называется 
`Eq` (от англ. *equals* -- равняется),
а класс печати выражений имеет имя `Show` (от англ. *show* 
-- показывать). Посмотрим на их определения:

Класс  `Eq`:

~~~
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
~~~

Класс `Show`:

~~~
class Show a where
    show :: a -> String
~~~

За ключевым словом `class` следует имя класса, тип-параметр
и ещё одно ключевое слово `where`. Далее с отступами пишутся
имена определённых в классе значений. Значения класса называются
*методами*.

Мы определяем лишь типы методов, конкретная реализация будет
зависеть от типа `a`. Методы определяются в экземплярах
классов типов, мы скоро к ним перейдём.

Программистская аналогия
класса типов это интерфейс. В интерфейсе определён набор
значений (как констант, так и функций), которые могут быть применены 
ко всем типам, которые поддерживают данный интерфейс.
К примеру, в интерфейсе "сравнение на равенство" для некоторого
типа `a` определены две функции: равно `(==)` и 
не равно `(/=)` с одинаковым
типом `a -> a -> Bool`, или в интерфейсе "печати" для
любого типа `a` определена одна функция `show` типа `a -> String`.

Математическая аналогия 
класса типов это алгебраическая система. Алгебра 
изучает свойства объекта в терминах операций, определённых на нём,
и взаимных ограничениях этих операций. Алгебраическая система представляет
собой набор операций и свойств этих операций. Этот подход позволяет
абстрагироваться от конкретного представления объектов. Например группа -- 
это все объекты данного типа `a`,  для которых определены
значения: константа -- единица типа `a`, бинарная операция
типа `a -> a -> a` и операция взятия обратного элемента,
типа `a -> a`. При этом на операции накладываются 
ограничения, называемые свойствами операций. Например, ассоциативность
бинарной операции, или тот факт, что единица с любым другим
элементом, применённые к бинарной операции, дают на выходе
исходный элемент.

Давайте определим класс для группы:

~~~
class Group a where
    e   :: a
    (+) :: a -> a -> a
    inv :: a -> a
~~~

Класс с именем `Group` имеет для некоторого типа `a` 
три метода: константу `e :: a`, операцию `(+) :: a -> a -> a`
и операцию взятия обратного элемента `inv :: a -> a`.

Как и в алгебре, в Haskell классы типов позволяют описывать 
сущности в терминах определённых на них операций или значений.
В примерах мы указываем лишь наличие операций и их типы, так же
и в классах типов. Класс типов содержит набор имён его значений 
с информацией о типах значений.

Определив класс `Group`, мы можем начать строить 
различные выражения, которые будут потом интерпретироваться
специфическим для типа образом:

~~~
twice :: Group a => a -> a
twice a = a + a

isE :: (Group a, Eq a) => a -> Bool
isE x = (x == e)
~~~

Обратите внимание на запись `Group a =>` и 
`(Group a, Eq a) =>`. Это называется контекстом объявления типа. 
В контексте мы говорим, что данный тип должен быть из 
класса `Group` или из классов `Group` и `Eq`. Это
значит, что для этого типа мы можем пользоваться методами
из этих классов.

В первой функции `twice` мы воспользовались методом
`(+)` из класса `Group`, поэтому функция имеет
контекст `Group a =>`. А во второй функции `isE` 
мы воспользовались методом `e` из класса `Group` и
методом `(==)` из класса `Eq`, поэтому функция
имеет контекст `(Group a, Eq a) =>`.

### Контекст классов типов. Суперклассы

Класс типов также может содержать контекст. Он указывается
между словом `class` и именем класса. Например


~~~
class IsPerson a

class IsPerson a => HasName a where
    name :: a -> String
~~~

Это определение говорит о том, что мы можем сделать 
экземпляр класса `HasName` 
только для тех типов, которые содержатся в `IsPerson`.
Мы говорим, что класс `HasName` содержится в `IsPerson`.
В этом случае класс из контекста `IsPerson` 
называют *суперклассом* для данного класса `HasName`.

Это сказывается на контексте объявления типа. Теперь, если мы пишем

~~~
fun :: HasName a => a -> a
~~~

Это означает, что мы можем пользоваться для значений типа
`a` как методами из класса `HasName`, так и методами 
из класса `IsPerson`. Поскольку если тип принадлежит 
классу `HasName`, то он также принадлежит и `IsPerson`. 

Запись `(IsPerson a => HasName a)` немного обманывает, было бы точнее 
писать `IsPerson a <= HasName a`, если тип `a` в классе `HasName`, то 
он точно в классе `IsPerson`, но в Haskell  закрепилась другая запись.

## Экземпляры классов типов

В *экземплярах* (instance) классов типов мы даём конкретное
наполнение для методов класса типов. Определение экземпляра
пишется так же, как и определение класса типа, но вместо `class`
мы пишем `instance`, вместо некоторого типа наш конкретный
тип, а вместо типов методов -- уравнения для них. 

Определим экземпляры для `Bool`

Класс `Eq`:

~~~
instance Eq Bool where
    (==) True  True  = True
    (==) False False = True
    (==) _     _     = False

    (/=) a b         = not (a == b)
~~~

Класс `Show`:

~~~
instance Show Bool where
    show True  = "True"
    show False = "False"
~~~

Класс `Group`:

~~~
instance Group Bool where
    e       = True
    (+) a b = and a b
    inv a   = not a
~~~
   

Отметим важность наличия свойств (ограничений) у значений,
определённых в классе типов. Так, например, в классе типов 
"сравнение на равенство" для любых двух значений данного типа
одна из операций должна вернуть "истину", а другая "ложь",
то есть два элемента данного типа либо равны, либо не равны.
Недостаточно определить равенство для конкретного типа, необходимо
убедиться в том, что для всех элементов данного типа свойства 
понятия равенства не нарушаются.

На самом деле приведённое выше определение экземпляра для `Group`
не верно, хотя по типам оно подходит. Оно не верно как раз 
из-за нарушения свойств. Для группы необходимо, чтобы для любого `a`
выполнялось:

~~~
 inv a + a == e
~~~

У нас лишь два значения, и это свойство не выполняется ни для одного
из них. Проверим:

~~~
    inv True   + True
 => (not True) + True
 => False      + True
 => and False    True
 => False

    inv False   + False
 => (not False) + False
 => True        + False
 => and True      False
 => False
~~~

Проверять свойства очень важно, потому что другие люди,
читая ваш код и используя ваши функции, будут на них рассчитывать.

## Ядро Haskell

Фуууухх. Мы закончили наш пробег. Теперь можно остановиться,
отдышаться и подвести итоги.
Давайте вспомним синтаксические конструкции, которые нам встретились.

#### Модули

~~~
module New(edef1, edef2, ..., edefN) where

import Old1(idef11, idef12, ..., idef1N)
import Old2(idef21, idef22, ..., idef2M)
...
import OldK(idefK1, idefK2, ..., idefKP)

-- определения :
...
~~~

Ключевые слова: `module`, `where`, `import`. Мы определили
модуль с именем `New`, который экспортирует определения
`edef1`, `edef2`, ... , `edefN`. И импортирует определения
из модулей `Old1`, `Old2`, и т.д.,
определения написаны в скобках за ключевыми словами `import` и
именами модулей.

#### Типы

Тип определяется с помощью:

* Перечисления альтернатив через `|` 
        
    ~~~
    data Type = Alt1 | Alt2 | ... | AltN
    ~~~

    Эту операцию называют *суммой* типов.

* Составления сложного типа из подтипов, пишем
        конструктор первым, затем через пробел подтипы:
   
    ~~~
    data Type = Name  Sub1  Sub2  ...  SubN
    ~~~

    Эту операцию называют *произведением* типов.

    Есть одно исключение: если тип состоит из двух подтипов,
    мы можем дать конструктору символьное (а не буквенное) имя,
    но оно должно начинаться с двоеточия `:`, как в случае списка,
    например, можно делать такие определения типов:

    ~~~
    data Type = Sub1 :+ Sub2 
    data Type = Sub1 :| Sub2 
    ~~~


* Комбинации суммы и произведения типов:

    ~~~
    data Type = Name1  Sub11  Sub12  ...  Sub1N
              | Name2  Sub21  Sub22  ...  Sub2M
              ...
              | NameK  SubK1  SubK2  ...  SubKP
    ~~~

Такие типы называют *алгебраическими типами данных*.
С помощью типов мы определяем основные понятия и способы
их комбинирования.

#### Значения

Как это ни странно, нам встретилась лишь одна операция
создания значений: *определение синонима*. Она пишется так

~~~
name x1  x2 ... xN = Expr1
name x1  x2 ... xN = Expr2
name x1  x2 ... xN = Expr3
~~~

Слева от знака равно стоит составное имя, а справа от знака
равно некоторое выражение, построенное согласно типам.
Разные комбинации имени `name` с параметрами определяют
разные уравнения для синонима `name`.

Также мы видели символ `_`, который означает "всё, что угодно"
на месте аргумента. А также мы  увидели, как с помощью переменных
можно перетаскивать значения из аргументов в результат.


#### Классы типов

Нам встретилась одна конструкция определения классов типов:

~~~
class Name a where
    method1 :: a -> ...
    method2 :: a -> ...
    ...
    methodN :: a -> ...
~~~

#### Экземпляры классов типов

Нам встретилась одна конструкция определения экземпляров
классов типов:

~~~
instance Name Type where
    method1 x1 ... xN = ...
    method2 x1 ... xM = ...
    ...
    methodN x1 ... xP = ...
~~~

#### Типы, значения и классы типов

Каждое значение имеет тип.
Значение `v` имеет тип `T` на Haskell: 

~~~
v :: T
~~~

Функциональный тип обозначается стрелкой: `a -> b`

~~~
fun :: a -> b
~~~

Тип значения может иметь контекст, он говорит о том, что
параметр должен принадлежать классу типов:

~~~
fun1 :: С a                 => a -> a
fun2 :: (C1 a, C2, ..., CN) => a -> a
~~~

#### Суперклассы

Также контекст может быть и у классов, запись

~~~
class A a => B a where
    ...
~~~

Означает, что класс `B` целиком содержится в `A`,
и перед тем как объявлять экземпляр для класса `B`,
необходимо определить экземпляр для класса `A`. 
При этом класс `A` называют суперклассом для `B`.

## Двумерный синтаксис

Наверное вы обратили внимание на то, что в Haskell
нет разделителей строк и дополнительных скобок, которые
бы указывали границы определения классов или функций. 
Компилятор Haskell ориентируется по переносам строки и 
отступам.

Так если мы пишем в классе:

~~~
class Eq a where
    (==) :: a -> a -> a
    (/=) :: a -> a -> a
~~~

По отступам за первой строкой определения компилятор
понимает, что класс содержит два метода. Если бы мы написали:

~~~
class Eq a where
    (==) :: a -> a -> a
(/=) :: a -> a -> a
~~~

То смысл был бы совсем другим. Теперь мы определяем
класс `Eq` с одним методом `==` и указываем
тип некоторого значения `(/=)`. Основное правило
такое: конструкции, расположенные на одном уровне, 
выравниваются с помощью отступов. Чем правее находится определение,
тем глубже оно вложено в какую-нибудь специальную
конструкцию. Пока нам встретилось лишь несколько специальных
конструкций, но дальше появятся и другие. 
Часто отступы набираются с помощью табуляции. Это удобно.
Но лучше пользоваться пробелами или настроить ваш любимый
текстовый редактор так, чтобы он автоматически заменял табуляцию
на пробелы. Зачем это нужно? Дело в том, что в разных редакторах
на табуляцию может быть назначено разное количество пробелов, 
так код набранный с двухзначной табуляцией будет очень трудно 
прочитать если открыть его в редакторе с четырьмя пробелами 
вместо табуляции. Поскольку очень часто табуляция перемежается 
с пробелами и выравнивание может "поехать". Поэтому признаком
хорошего стиля в Haskell считается полный отказ от табуляции.


## Краткое содержание

Итак подведём итоги: у нас есть две операции для определения типов
(сумма и произведение) и по одной для значений (синонимы), 
классов типов и экземпляров. А также
бесконечное множество их комбинаций, из которых и состоит
увлекательный мир Haskell. Конечно не только из них, есть
нюансы, синтаксический сахар, расширения языка. Об этом
и многом другом мы узнаем из этой книги. 

Интересно, что в Haskell, несмотря на обилие 
конструкций и библиотек, ты чувствуешь, что за ними стоит
нечто из мира науки, мира чистого знания. Ты не просто учишься 
пользоваться определёнными функциями или классами, а узнаёшь
что-то новое и красивое.

## Упражнения

Потренируйтесь в описаниях в рамках системы типов.
Вы определяете базовые понятия и способы их комбинирования.
У вас есть три операции:

* Сумма типов `data T = A1 | A2`. Перечисление альтернатив
            
* Произведение типов `data T = S S1 S2`. 
    Этим мы говорим, что понятие состоит из нескольких.

* Взятие в список `[T]`. Обозначает множественное
    число, элементов типа `T` их может быть несколько.

Опишите что-либо: комнату, дорогу, город, человека,
главу из книги, математическую теорию, всё что угодно.

Ниже приведён пример для понятий из этой главы:

~~~
data Program = Programm ProgramType [Module]
data ProgramType = Executable | Library

data Module = Module [Definition]

data Definition = Definition DefinitionType Element
data DefinitionType = Export | Inner

data Element = ET Type | EV Value | EC Class | EI Instance

data Type     = Type String
data Value    = Value String
data Class    = Class String
data Instance = Instance String
~~~

После того как вы закончите с описанием, подумайте,
какие производные связи могли бы вас заинтересовать.
Какие функции вам бы хотелось определить в
этом описании. Выпишите их типы без определений, например так:

~~~
-- Все объявления типов в модуле
getTypes :: Module -> [Type]

-- Провести редукцию значения:
reduce :: Value -> Program -> Value

-- Проверить типы:
checkTypes :: Program -> Bool

-- Заменить все определения в модуле на новые
setDefinitions    :: Module -> [Definition] -> Module

-- Упорядочить определения по какому-лбо принципу
orderDefinitions :: [Definition] -> [Definition]
~~~

Подумайте: если у вас есть все эти функции, какие производные
значения могли бы вам сказать что-нибудь интересное.

